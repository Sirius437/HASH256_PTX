#!/usr/bin/env python3
"""
Generate complete SHA256 PTX kernel with all 64 rounds
This script generates the full unrolled SHA256 implementation
"""

def generate_round(round_num, w_expr):
    """Generate PTX code for one SHA256 round"""
    k_offset = round_num * 4
    
    code = f"""
    // Round {round_num}
    ld.const.u32    %k_val, [K+{k_offset}];
    {w_expr}
    // Ch(e,f,g) = (e & f) ^ (~e & g)
    and.b32         %r10, %e, %f;
    not.b32         %r11, %e;
    and.b32         %r11, %r11, %g;
    xor.b32         %ch, %r10, %r11;
    // Maj(a,b,c) = (a & b) ^ (a & c) ^ (b & c)
    and.b32         %r12, %a, %b;
    and.b32         %r13, %a, %c;
    and.b32         %r14, %b, %c;
    xor.b32         %maj, %r12, %r13;
    xor.b32         %maj, %maj, %r14;
    // Sigma1(e) = ROTR(e,6) ^ ROTR(e,11) ^ ROTR(e,25)
    shr.u32         %r15, %e, 6;
    shl.b32         %r16, %e, 26;
    or.b32          %r17, %r15, %r16;
    shr.u32         %r18, %e, 11;
    shl.b32         %r19, %e, 21;
    or.b32          %r20, %r18, %r19;
    shr.u32         %r21, %e, 25;
    shl.b32         %r22, %e, 7;
    or.b32          %r23, %r21, %r22;
    xor.b32         %S1, %r17, %r20;
    xor.b32         %S1, %S1, %r23;
    // Sigma0(a) = ROTR(a,2) ^ ROTR(a,13) ^ ROTR(a,22)
    shr.u32         %r24, %a, 2;
    shl.b32         %r25, %a, 30;
    or.b32          %r26, %r24, %r25;
    shr.u32         %r27, %a, 13;
    shl.b32         %r28, %a, 19;
    or.b32          %r29, %r27, %r28;
    shr.u32         %r30, %a, 22;
    shl.b32         %r31, %a, 10;
    or.b32          %r32, %r30, %r31;
    xor.b32         %S0, %r26, %r29;
    xor.b32         %S0, %S0, %r32;
    // t1 = h + Sigma1 + ch + k + w
    add.u32         %t1, %h, %S1;
    add.u32         %t1, %t1, %ch;
    add.u32         %t1, %t1, %k_val;
    add.u32         %t1, %t1, %w_val;
    // t2 = Sigma0 + maj
    add.u32         %t2, %S0, %maj;
    // Update working variables
    mov.u32         %h, %g;
    mov.u32         %g, %f;
    mov.u32         %f, %e;
    add.u32         %e, %d, %t1;
    mov.u32         %d, %c;
    mov.u32         %c, %b;
    mov.u32         %b, %a;
    add.u32         %a, %t1, %t2;
"""
    
    return code

def generate_message_schedule_extension(i):
    """Generate code to extend message schedule for round i (16-63)"""
    # W[i] = sigma1(W[i-2]) + W[i-7] + sigma0(W[i-15]) + W[i-16]
    # sigma0(x) = ROTR(x,7) ^ ROTR(x,18) ^ SHR(x,3)
    # sigma1(x) = ROTR(x,17) ^ ROTR(x,19) ^ SHR(x,10)
    
    w_i_2 = f"%w{(i-2) % 16}"
    w_i_7 = f"%w{(i-7) % 16}"
    w_i_15 = f"%w{(i-15) % 16}"
    w_i_16 = f"%w{(i-16) % 16}"
    w_i = f"%w{i % 16}"
    
    code = f"""    // Extend W[{i}]
    // Save W[{i-16}] before we overwrite it (if w_i == w_i_16)
    mov.u32         %r70, {w_i_16};
    // sigma1(W[{i-2}])
    shr.u32         %r50, {w_i_2}, 17;
    shl.b32         %r51, {w_i_2}, 15;
    or.b32          %r52, %r50, %r51;
    shr.u32         %r53, {w_i_2}, 19;
    shl.b32         %r54, {w_i_2}, 13;
    or.b32          %r55, %r53, %r54;
    shr.u32         %r56, {w_i_2}, 10;
    xor.b32         %s1, %r52, %r55;
    xor.b32         %s1, %s1, %r56;
    // sigma0(W[{i-15}])
    shr.u32         %r57, {w_i_15}, 7;
    shl.b32         %r58, {w_i_15}, 25;
    or.b32          %r59, %r57, %r58;
    shr.u32         %r60, {w_i_15}, 18;
    shl.b32         %r61, {w_i_15}, 14;
    or.b32          %r62, %r60, %r61;
    shr.u32         %r63, {w_i_15}, 3;
    xor.b32         %s0, %r59, %r62;
    xor.b32         %s0, %s0, %r63;
    // W[{i}] = sigma1 + W[{i-7}] + sigma0 + W[{i-16}]
    add.u32         {w_i}, %s1, {w_i_7};
    add.u32         {w_i}, {w_i}, %s0;
    add.u32         {w_i}, {w_i}, %r70;
"""
    
    # Debug output removed for production
    
    return code

def generate_all_rounds():
    """Generate all 64 SHA256 rounds"""
    rounds = []
    
    # Rounds 0-15: use W[0-15] directly
    for i in range(16):
        w_expr = f"mov.u32         %w_val, %w{i};"
        rounds.append(generate_round(i, w_expr))
    
    # Rounds 16-63: extend message schedule
    for i in range(16, 64):
        # First extend the message schedule
        extend_code = generate_message_schedule_extension(i)
        # Then use the extended value
        w_expr = f"mov.u32         %w_val, %w{i % 16};"
        rounds.append(extend_code + generate_round(i, w_expr))
    
    return "\n".join(rounds)

def generate_full_kernel():
    """Generate the complete SHA256 PTX kernel"""
    
    header = """// SHA256 PTX Kernel - Auto-generated with all 64 rounds
// Generated by generate_sha256_ptx.py

.version 8.7
.target sm_120
.address_size 64

// SHA256 K constants
.const .align 4 .b32 K[64] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

.visible .entry sha256_kernel(
    .param .u64 param_input,
    .param .u64 param_output,
    .param .u32 param_num_keys
)
{
    .reg .b32   %r<100>;
    .reg .b64   %rd<10>;
    .reg .pred  %p<10>;
    
    .reg .b32   %thread_id;
    .reg .b64   %input_ptr, %output_ptr;
    .reg .b64   %input_base, %output_base;
    
    // SHA256 state
    .reg .b32   %a, %b, %c, %d, %e, %f, %g, %h;
    .reg .b32   %h0, %h1, %h2, %h3, %h4, %h5, %h6, %h7;
    
    // Message schedule
    .reg .b32   %w0, %w1, %w2, %w3, %w4, %w5, %w6, %w7;
    .reg .b32   %w8, %w9, %w10, %w11, %w12, %w13, %w14, %w15;
    
    // Temporaries
    .reg .b32   %t1, %t2, %ch, %maj;
    .reg .b32   %s0, %s1;  // message schedule sigma (lowercase)
    .reg .b32   %S0, %S1;  // round Sigma (uppercase)
    .reg .b32   %k_val, %w_val;
    
    // Thread ID calculation
    mov.u32     %r0, %ctaid.x;
    mov.u32     %r1, %ntid.x;
    mov.u32     %r2, %tid.x;
    mad.lo.s32  %thread_id, %r0, %r1, %r2;
    
    // Load parameters
    ld.param.u64    %input_base, [param_input];
    ld.param.u64    %output_base, [param_output];
    ld.param.u32    %r3, [param_num_keys];
    
    // Bounds check
    setp.ge.u32     %p0, %thread_id, %r3;
    @%p0 bra        END;
    
    // Convert to global addresses
    cvta.to.global.u64  %input_base, %input_base;
    cvta.to.global.u64  %output_base, %output_base;
    
    // Calculate pointers
    mul.wide.u32    %rd0, %thread_id, 33;
    add.u64         %input_ptr, %input_base, %rd0;
    mul.wide.u32    %rd1, %thread_id, 32;
    add.u64         %output_ptr, %output_base, %rd1;
    
    // Initialize hash values
    mov.u32     %h0, 0x6a09e667;
    mov.u32     %h1, 0xbb67ae85;
    mov.u32     %h2, 0x3c6ef372;
    mov.u32     %h3, 0xa54ff53a;
    mov.u32     %h4, 0x510e527f;
    mov.u32     %h5, 0x9b05688c;
    mov.u32     %h6, 0x1f83d9ab;
    mov.u32     %h7, 0x5be0cd19;
"""
    
    # Load input section (33 bytes -> 16 words with padding)
    load_input = """
    // Load 33-byte input as big-endian words
"""
    for i in range(8):
        offset = i * 4
        load_input += f"""    ld.global.u8    %r4, [%input_ptr+{offset}];
    ld.global.u8    %r5, [%input_ptr+{offset+1}];
    ld.global.u8    %r6, [%input_ptr+{offset+2}];
    ld.global.u8    %r7, [%input_ptr+{offset+3}];
    shl.b32         %r4, %r4, 24;
    shl.b32         %r5, %r5, 16;
    shl.b32         %r6, %r6, 8;
    or.b32          %w{i}, %r4, %r5;
    or.b32          %w{i}, %w{i}, %r6;
    or.b32          %w{i}, %w{i}, %r7;
"""
    
    # Last byte + padding
    load_input += """    ld.global.u8    %r4, [%input_ptr+32];
    shl.b32         %r4, %r4, 24;
    or.b32          %w8, %r4, 0x00800000;
    mov.u32         %w9, 0;
    mov.u32         %w10, 0;
    mov.u32         %w11, 0;
    mov.u32         %w12, 0;
    mov.u32         %w13, 0;
    mov.u32         %w14, 0;
    mov.u32         %w15, 0x00000108;
    
    // Initialize working variables
    mov.u32         %a, %h0;
    mov.u32         %b, %h1;
    mov.u32         %c, %h2;
    mov.u32         %d, %h3;
    mov.u32         %e, %h4;
    mov.u32         %f, %h5;
    mov.u32         %g, %h6;
    mov.u32         %h, %h7;
"""
    
    # All 64 rounds
    rounds = generate_all_rounds()
    
    # Final addition and output
    footer = """
    // Add compressed hash to initial values
    add.u32         %h0, %h0, %a;
    add.u32         %h1, %h1, %b;
    add.u32         %h2, %h2, %c;
    add.u32         %h3, %h3, %d;
    add.u32         %h4, %h4, %e;
    add.u32         %h5, %h5, %f;
    add.u32         %h6, %h6, %g;
    add.u32         %h7, %h7, %h;
    
    // Store output as big-endian bytes
"""
    for i in range(8):
        offset = i * 4
        footer += f"""    shr.u32         %r40, %h{i}, 24;
    st.global.u8    [%output_ptr+{offset}], %r40;
    shr.u32         %r41, %h{i}, 16;
    st.global.u8    [%output_ptr+{offset+1}], %r41;
    shr.u32         %r42, %h{i}, 8;
    st.global.u8    [%output_ptr+{offset+2}], %r42;
    st.global.u8    [%output_ptr+{offset+3}], %h{i};
"""
    
    footer += """
END:
    ret;
}
"""
    
    return header + load_input + rounds + footer

if __name__ == "__main__":
    kernel_code = generate_full_kernel()
    
    with open("ptx/sha256_kernel_full.ptx", "w") as f:
        f.write(kernel_code)
    
    print("âœ“ Generated ptx/sha256_kernel_full.ptx")
    print(f"  Total lines: {len(kernel_code.splitlines())}")
    print("  All 64 rounds included")
    print("  Ready to compile and test!")
